// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_FUGUE_FUGUE_SCHEMA_H_
#define FLATBUFFERS_GENERATED_FUGUE_FUGUE_SCHEMA_H_

#include "flatbuffers/flatbuffers.h"
#include "flatbuffers/flexbuffers.h"

namespace fugue {
namespace schema {

struct Architecture;
struct ArchitectureBuilder;

struct Segment;
struct SegmentBuilder;

struct InterRef;
struct InterRefBuilder;

struct IntraRef;
struct IntraRefBuilder;

struct BasicBlock;
struct BasicBlockBuilder;

struct Function;
struct FunctionBuilder;

struct Metadata;
struct MetadataBuilder;

struct Project;
struct ProjectBuilder;

struct Architecture FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ArchitectureBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PROCESSOR = 4,
    VT_ENDIAN = 6,
    VT_BITS = 8,
    VT_VARIANT = 10,
    VT_AUXILIARY = 12
  };
  const flatbuffers::String *processor() const {
    return GetPointer<const flatbuffers::String *>(VT_PROCESSOR);
  }
  bool endian() const {
    return GetField<uint8_t>(VT_ENDIAN, 0) != 0;
  }
  uint32_t bits() const {
    return GetField<uint32_t>(VT_BITS, 0);
  }
  const flatbuffers::String *variant() const {
    return GetPointer<const flatbuffers::String *>(VT_VARIANT);
  }
  const flatbuffers::Vector<uint8_t> *auxiliary() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_AUXILIARY);
  }
  flexbuffers::Reference auxiliary_flexbuffer_root() const {
    return flexbuffers::GetRoot(auxiliary()->Data(), auxiliary()->size());
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PROCESSOR) &&
           verifier.VerifyString(processor()) &&
           VerifyField<uint8_t>(verifier, VT_ENDIAN) &&
           VerifyField<uint32_t>(verifier, VT_BITS) &&
           VerifyOffset(verifier, VT_VARIANT) &&
           verifier.VerifyString(variant()) &&
           VerifyOffset(verifier, VT_AUXILIARY) &&
           verifier.VerifyVector(auxiliary()) &&
           verifier.EndTable();
  }
};

struct ArchitectureBuilder {
  typedef Architecture Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_processor(flatbuffers::Offset<flatbuffers::String> processor) {
    fbb_.AddOffset(Architecture::VT_PROCESSOR, processor);
  }
  void add_endian(bool endian) {
    fbb_.AddElement<uint8_t>(Architecture::VT_ENDIAN, static_cast<uint8_t>(endian), 0);
  }
  void add_bits(uint32_t bits) {
    fbb_.AddElement<uint32_t>(Architecture::VT_BITS, bits, 0);
  }
  void add_variant(flatbuffers::Offset<flatbuffers::String> variant) {
    fbb_.AddOffset(Architecture::VT_VARIANT, variant);
  }
  void add_auxiliary(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> auxiliary) {
    fbb_.AddOffset(Architecture::VT_AUXILIARY, auxiliary);
  }
  explicit ArchitectureBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Architecture> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Architecture>(end);
    return o;
  }
};

inline flatbuffers::Offset<Architecture> CreateArchitecture(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> processor = 0,
    bool endian = false,
    uint32_t bits = 0,
    flatbuffers::Offset<flatbuffers::String> variant = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> auxiliary = 0) {
  ArchitectureBuilder builder_(_fbb);
  builder_.add_auxiliary(auxiliary);
  builder_.add_variant(variant);
  builder_.add_bits(bits);
  builder_.add_processor(processor);
  builder_.add_endian(endian);
  return builder_.Finish();
}

inline flatbuffers::Offset<Architecture> CreateArchitectureDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *processor = nullptr,
    bool endian = false,
    uint32_t bits = 0,
    const char *variant = nullptr,
    const std::vector<uint8_t> *auxiliary = nullptr) {
  auto processor__ = processor ? _fbb.CreateString(processor) : 0;
  auto variant__ = variant ? _fbb.CreateString(variant) : 0;
  auto auxiliary__ = auxiliary ? _fbb.CreateVector<uint8_t>(*auxiliary) : 0;
  return fugue::schema::CreateArchitecture(
      _fbb,
      processor__,
      endian,
      bits,
      variant__,
      auxiliary__);
}

struct Segment FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SegmentBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_NAME = 4,
    VT_ADDRESS = 6,
    VT_SIZE = 8,
    VT_ADDRESS_SIZE = 10,
    VT_ALIGNMENT = 12,
    VT_BITS = 14,
    VT_ENDIAN = 16,
    VT_CODE = 18,
    VT_DATA = 20,
    VT_EXTERNAL = 22,
    VT_READABLE = 24,
    VT_WRITABLE = 26,
    VT_EXECUTABLE = 28,
    VT_BYTES = 30,
    VT_AUXILIARY = 32
  };
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint64_t address() const {
    return GetField<uint64_t>(VT_ADDRESS, 0);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  uint32_t address_size() const {
    return GetField<uint32_t>(VT_ADDRESS_SIZE, 0);
  }
  uint32_t alignment() const {
    return GetField<uint32_t>(VT_ALIGNMENT, 0);
  }
  uint32_t bits() const {
    return GetField<uint32_t>(VT_BITS, 0);
  }
  bool endian() const {
    return GetField<uint8_t>(VT_ENDIAN, 0) != 0;
  }
  bool code() const {
    return GetField<uint8_t>(VT_CODE, 0) != 0;
  }
  bool data() const {
    return GetField<uint8_t>(VT_DATA, 0) != 0;
  }
  bool external() const {
    return GetField<uint8_t>(VT_EXTERNAL, 0) != 0;
  }
  bool readable() const {
    return GetField<uint8_t>(VT_READABLE, 0) != 0;
  }
  bool writable() const {
    return GetField<uint8_t>(VT_WRITABLE, 0) != 0;
  }
  bool executable() const {
    return GetField<uint8_t>(VT_EXECUTABLE, 0) != 0;
  }
  const flatbuffers::Vector<uint8_t> *bytes() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_BYTES);
  }
  const flatbuffers::Vector<uint8_t> *auxiliary() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_AUXILIARY);
  }
  flexbuffers::Reference auxiliary_flexbuffer_root() const {
    return flexbuffers::GetRoot(auxiliary()->Data(), auxiliary()->size());
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint64_t>(verifier, VT_ADDRESS) &&
           VerifyField<uint32_t>(verifier, VT_SIZE) &&
           VerifyField<uint32_t>(verifier, VT_ADDRESS_SIZE) &&
           VerifyField<uint32_t>(verifier, VT_ALIGNMENT) &&
           VerifyField<uint32_t>(verifier, VT_BITS) &&
           VerifyField<uint8_t>(verifier, VT_ENDIAN) &&
           VerifyField<uint8_t>(verifier, VT_CODE) &&
           VerifyField<uint8_t>(verifier, VT_DATA) &&
           VerifyField<uint8_t>(verifier, VT_EXTERNAL) &&
           VerifyField<uint8_t>(verifier, VT_READABLE) &&
           VerifyField<uint8_t>(verifier, VT_WRITABLE) &&
           VerifyField<uint8_t>(verifier, VT_EXECUTABLE) &&
           VerifyOffset(verifier, VT_BYTES) &&
           verifier.VerifyVector(bytes()) &&
           VerifyOffset(verifier, VT_AUXILIARY) &&
           verifier.VerifyVector(auxiliary()) &&
           verifier.EndTable();
  }
};

struct SegmentBuilder {
  typedef Segment Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(Segment::VT_NAME, name);
  }
  void add_address(uint64_t address) {
    fbb_.AddElement<uint64_t>(Segment::VT_ADDRESS, address, 0);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(Segment::VT_SIZE, size, 0);
  }
  void add_address_size(uint32_t address_size) {
    fbb_.AddElement<uint32_t>(Segment::VT_ADDRESS_SIZE, address_size, 0);
  }
  void add_alignment(uint32_t alignment) {
    fbb_.AddElement<uint32_t>(Segment::VT_ALIGNMENT, alignment, 0);
  }
  void add_bits(uint32_t bits) {
    fbb_.AddElement<uint32_t>(Segment::VT_BITS, bits, 0);
  }
  void add_endian(bool endian) {
    fbb_.AddElement<uint8_t>(Segment::VT_ENDIAN, static_cast<uint8_t>(endian), 0);
  }
  void add_code(bool code) {
    fbb_.AddElement<uint8_t>(Segment::VT_CODE, static_cast<uint8_t>(code), 0);
  }
  void add_data(bool data) {
    fbb_.AddElement<uint8_t>(Segment::VT_DATA, static_cast<uint8_t>(data), 0);
  }
  void add_external(bool external) {
    fbb_.AddElement<uint8_t>(Segment::VT_EXTERNAL, static_cast<uint8_t>(external), 0);
  }
  void add_readable(bool readable) {
    fbb_.AddElement<uint8_t>(Segment::VT_READABLE, static_cast<uint8_t>(readable), 0);
  }
  void add_writable(bool writable) {
    fbb_.AddElement<uint8_t>(Segment::VT_WRITABLE, static_cast<uint8_t>(writable), 0);
  }
  void add_executable(bool executable) {
    fbb_.AddElement<uint8_t>(Segment::VT_EXECUTABLE, static_cast<uint8_t>(executable), 0);
  }
  void add_bytes(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bytes) {
    fbb_.AddOffset(Segment::VT_BYTES, bytes);
  }
  void add_auxiliary(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> auxiliary) {
    fbb_.AddOffset(Segment::VT_AUXILIARY, auxiliary);
  }
  explicit SegmentBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Segment> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Segment>(end);
    return o;
  }
};

inline flatbuffers::Offset<Segment> CreateSegment(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint64_t address = 0,
    uint32_t size = 0,
    uint32_t address_size = 0,
    uint32_t alignment = 0,
    uint32_t bits = 0,
    bool endian = false,
    bool code = false,
    bool data = false,
    bool external = false,
    bool readable = false,
    bool writable = false,
    bool executable = false,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> bytes = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> auxiliary = 0) {
  SegmentBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_auxiliary(auxiliary);
  builder_.add_bytes(bytes);
  builder_.add_bits(bits);
  builder_.add_alignment(alignment);
  builder_.add_address_size(address_size);
  builder_.add_size(size);
  builder_.add_name(name);
  builder_.add_executable(executable);
  builder_.add_writable(writable);
  builder_.add_readable(readable);
  builder_.add_external(external);
  builder_.add_data(data);
  builder_.add_code(code);
  builder_.add_endian(endian);
  return builder_.Finish();
}

inline flatbuffers::Offset<Segment> CreateSegmentDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    uint64_t address = 0,
    uint32_t size = 0,
    uint32_t address_size = 0,
    uint32_t alignment = 0,
    uint32_t bits = 0,
    bool endian = false,
    bool code = false,
    bool data = false,
    bool external = false,
    bool readable = false,
    bool writable = false,
    bool executable = false,
    const std::vector<uint8_t> *bytes = nullptr,
    const std::vector<uint8_t> *auxiliary = nullptr) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  auto bytes__ = bytes ? _fbb.CreateVector<uint8_t>(*bytes) : 0;
  auto auxiliary__ = auxiliary ? _fbb.CreateVector<uint8_t>(*auxiliary) : 0;
  return fugue::schema::CreateSegment(
      _fbb,
      name__,
      address,
      size,
      address_size,
      alignment,
      bits,
      endian,
      code,
      data,
      external,
      readable,
      writable,
      executable,
      bytes__,
      auxiliary__);
}

struct InterRef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef InterRefBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDRESS = 4,
    VT_SOURCE = 6,
    VT_TARGET = 8,
    VT_CALL = 10,
    VT_AUXILIARY = 12
  };
  uint64_t address() const {
    return GetField<uint64_t>(VT_ADDRESS, 0);
  }
  uint32_t source() const {
    return GetField<uint32_t>(VT_SOURCE, 4294967295);
  }
  uint32_t target() const {
    return GetField<uint32_t>(VT_TARGET, 0);
  }
  bool call() const {
    return GetField<uint8_t>(VT_CALL, 0) != 0;
  }
  const flatbuffers::Vector<uint8_t> *auxiliary() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_AUXILIARY);
  }
  flexbuffers::Reference auxiliary_flexbuffer_root() const {
    return flexbuffers::GetRoot(auxiliary()->Data(), auxiliary()->size());
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ADDRESS) &&
           VerifyField<uint32_t>(verifier, VT_SOURCE) &&
           VerifyField<uint32_t>(verifier, VT_TARGET) &&
           VerifyField<uint8_t>(verifier, VT_CALL) &&
           VerifyOffset(verifier, VT_AUXILIARY) &&
           verifier.VerifyVector(auxiliary()) &&
           verifier.EndTable();
  }
};

struct InterRefBuilder {
  typedef InterRef Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_address(uint64_t address) {
    fbb_.AddElement<uint64_t>(InterRef::VT_ADDRESS, address, 0);
  }
  void add_source(uint32_t source) {
    fbb_.AddElement<uint32_t>(InterRef::VT_SOURCE, source, 4294967295);
  }
  void add_target(uint32_t target) {
    fbb_.AddElement<uint32_t>(InterRef::VT_TARGET, target, 0);
  }
  void add_call(bool call) {
    fbb_.AddElement<uint8_t>(InterRef::VT_CALL, static_cast<uint8_t>(call), 0);
  }
  void add_auxiliary(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> auxiliary) {
    fbb_.AddOffset(InterRef::VT_AUXILIARY, auxiliary);
  }
  explicit InterRefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<InterRef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<InterRef>(end);
    return o;
  }
};

inline flatbuffers::Offset<InterRef> CreateInterRef(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t address = 0,
    uint32_t source = 4294967295,
    uint32_t target = 0,
    bool call = false,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> auxiliary = 0) {
  InterRefBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_auxiliary(auxiliary);
  builder_.add_target(target);
  builder_.add_source(source);
  builder_.add_call(call);
  return builder_.Finish();
}

inline flatbuffers::Offset<InterRef> CreateInterRefDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t address = 0,
    uint32_t source = 4294967295,
    uint32_t target = 0,
    bool call = false,
    const std::vector<uint8_t> *auxiliary = nullptr) {
  auto auxiliary__ = auxiliary ? _fbb.CreateVector<uint8_t>(*auxiliary) : 0;
  return fugue::schema::CreateInterRef(
      _fbb,
      address,
      source,
      target,
      call,
      auxiliary__);
}

struct IntraRef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef IntraRefBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SOURCE = 4,
    VT_TARGET = 6,
    VT_FUNCTION = 8,
    VT_AUXILIARY = 10
  };
  uint64_t source() const {
    return GetField<uint64_t>(VT_SOURCE, 0);
  }
  uint64_t target() const {
    return GetField<uint64_t>(VT_TARGET, 0);
  }
  uint32_t function() const {
    return GetField<uint32_t>(VT_FUNCTION, 0);
  }
  const flatbuffers::Vector<uint8_t> *auxiliary() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_AUXILIARY);
  }
  flexbuffers::Reference auxiliary_flexbuffer_root() const {
    return flexbuffers::GetRoot(auxiliary()->Data(), auxiliary()->size());
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_SOURCE) &&
           VerifyField<uint64_t>(verifier, VT_TARGET) &&
           VerifyField<uint32_t>(verifier, VT_FUNCTION) &&
           VerifyOffset(verifier, VT_AUXILIARY) &&
           verifier.VerifyVector(auxiliary()) &&
           verifier.EndTable();
  }
};

struct IntraRefBuilder {
  typedef IntraRef Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_source(uint64_t source) {
    fbb_.AddElement<uint64_t>(IntraRef::VT_SOURCE, source, 0);
  }
  void add_target(uint64_t target) {
    fbb_.AddElement<uint64_t>(IntraRef::VT_TARGET, target, 0);
  }
  void add_function(uint32_t function) {
    fbb_.AddElement<uint32_t>(IntraRef::VT_FUNCTION, function, 0);
  }
  void add_auxiliary(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> auxiliary) {
    fbb_.AddOffset(IntraRef::VT_AUXILIARY, auxiliary);
  }
  explicit IntraRefBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<IntraRef> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<IntraRef>(end);
    return o;
  }
};

inline flatbuffers::Offset<IntraRef> CreateIntraRef(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t source = 0,
    uint64_t target = 0,
    uint32_t function = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> auxiliary = 0) {
  IntraRefBuilder builder_(_fbb);
  builder_.add_target(target);
  builder_.add_source(source);
  builder_.add_auxiliary(auxiliary);
  builder_.add_function(function);
  return builder_.Finish();
}

inline flatbuffers::Offset<IntraRef> CreateIntraRefDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t source = 0,
    uint64_t target = 0,
    uint32_t function = 0,
    const std::vector<uint8_t> *auxiliary = nullptr) {
  auto auxiliary__ = auxiliary ? _fbb.CreateVector<uint8_t>(*auxiliary) : 0;
  return fugue::schema::CreateIntraRef(
      _fbb,
      source,
      target,
      function,
      auxiliary__);
}

struct BasicBlock FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef BasicBlockBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ADDRESS = 4,
    VT_SIZE = 6,
    VT_ARCHITECTURE = 8,
    VT_PREDECESSORS = 10,
    VT_SUCCESSORS = 12,
    VT_AUXILIARY = 14
  };
  uint64_t address() const {
    return GetField<uint64_t>(VT_ADDRESS, 0);
  }
  uint32_t size() const {
    return GetField<uint32_t>(VT_SIZE, 0);
  }
  uint32_t architecture() const {
    return GetField<uint32_t>(VT_ARCHITECTURE, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fugue::schema::IntraRef>> *predecessors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fugue::schema::IntraRef>> *>(VT_PREDECESSORS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fugue::schema::IntraRef>> *successors() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fugue::schema::IntraRef>> *>(VT_SUCCESSORS);
  }
  const flatbuffers::Vector<uint8_t> *auxiliary() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_AUXILIARY);
  }
  flexbuffers::Reference auxiliary_flexbuffer_root() const {
    return flexbuffers::GetRoot(auxiliary()->Data(), auxiliary()->size());
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint64_t>(verifier, VT_ADDRESS) &&
           VerifyField<uint32_t>(verifier, VT_SIZE) &&
           VerifyField<uint32_t>(verifier, VT_ARCHITECTURE) &&
           VerifyOffset(verifier, VT_PREDECESSORS) &&
           verifier.VerifyVector(predecessors()) &&
           verifier.VerifyVectorOfTables(predecessors()) &&
           VerifyOffset(verifier, VT_SUCCESSORS) &&
           verifier.VerifyVector(successors()) &&
           verifier.VerifyVectorOfTables(successors()) &&
           VerifyOffset(verifier, VT_AUXILIARY) &&
           verifier.VerifyVector(auxiliary()) &&
           verifier.EndTable();
  }
};

struct BasicBlockBuilder {
  typedef BasicBlock Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_address(uint64_t address) {
    fbb_.AddElement<uint64_t>(BasicBlock::VT_ADDRESS, address, 0);
  }
  void add_size(uint32_t size) {
    fbb_.AddElement<uint32_t>(BasicBlock::VT_SIZE, size, 0);
  }
  void add_architecture(uint32_t architecture) {
    fbb_.AddElement<uint32_t>(BasicBlock::VT_ARCHITECTURE, architecture, 0);
  }
  void add_predecessors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fugue::schema::IntraRef>>> predecessors) {
    fbb_.AddOffset(BasicBlock::VT_PREDECESSORS, predecessors);
  }
  void add_successors(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fugue::schema::IntraRef>>> successors) {
    fbb_.AddOffset(BasicBlock::VT_SUCCESSORS, successors);
  }
  void add_auxiliary(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> auxiliary) {
    fbb_.AddOffset(BasicBlock::VT_AUXILIARY, auxiliary);
  }
  explicit BasicBlockBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<BasicBlock> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BasicBlock>(end);
    return o;
  }
};

inline flatbuffers::Offset<BasicBlock> CreateBasicBlock(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t address = 0,
    uint32_t size = 0,
    uint32_t architecture = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fugue::schema::IntraRef>>> predecessors = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fugue::schema::IntraRef>>> successors = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> auxiliary = 0) {
  BasicBlockBuilder builder_(_fbb);
  builder_.add_address(address);
  builder_.add_auxiliary(auxiliary);
  builder_.add_successors(successors);
  builder_.add_predecessors(predecessors);
  builder_.add_architecture(architecture);
  builder_.add_size(size);
  return builder_.Finish();
}

inline flatbuffers::Offset<BasicBlock> CreateBasicBlockDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint64_t address = 0,
    uint32_t size = 0,
    uint32_t architecture = 0,
    const std::vector<flatbuffers::Offset<fugue::schema::IntraRef>> *predecessors = nullptr,
    const std::vector<flatbuffers::Offset<fugue::schema::IntraRef>> *successors = nullptr,
    const std::vector<uint8_t> *auxiliary = nullptr) {
  auto predecessors__ = predecessors ? _fbb.CreateVector<flatbuffers::Offset<fugue::schema::IntraRef>>(*predecessors) : 0;
  auto successors__ = successors ? _fbb.CreateVector<flatbuffers::Offset<fugue::schema::IntraRef>>(*successors) : 0;
  auto auxiliary__ = auxiliary ? _fbb.CreateVector<uint8_t>(*auxiliary) : 0;
  return fugue::schema::CreateBasicBlock(
      _fbb,
      address,
      size,
      architecture,
      predecessors__,
      successors__,
      auxiliary__);
}

struct Function FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef FunctionBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_SYMBOL = 4,
    VT_ADDRESS = 6,
    VT_ENTRY = 8,
    VT_BLOCKS = 10,
    VT_REFERENCES = 12,
    VT_AUXILIARY = 14
  };
  const flatbuffers::String *symbol() const {
    return GetPointer<const flatbuffers::String *>(VT_SYMBOL);
  }
  uint64_t address() const {
    return GetField<uint64_t>(VT_ADDRESS, 0);
  }
  uint64_t entry() const {
    return GetField<uint64_t>(VT_ENTRY, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fugue::schema::BasicBlock>> *blocks() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fugue::schema::BasicBlock>> *>(VT_BLOCKS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fugue::schema::InterRef>> *references() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fugue::schema::InterRef>> *>(VT_REFERENCES);
  }
  const flatbuffers::Vector<uint8_t> *auxiliary() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_AUXILIARY);
  }
  flexbuffers::Reference auxiliary_flexbuffer_root() const {
    return flexbuffers::GetRoot(auxiliary()->Data(), auxiliary()->size());
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_SYMBOL) &&
           verifier.VerifyString(symbol()) &&
           VerifyField<uint64_t>(verifier, VT_ADDRESS) &&
           VerifyField<uint64_t>(verifier, VT_ENTRY) &&
           VerifyOffset(verifier, VT_BLOCKS) &&
           verifier.VerifyVector(blocks()) &&
           verifier.VerifyVectorOfTables(blocks()) &&
           VerifyOffset(verifier, VT_REFERENCES) &&
           verifier.VerifyVector(references()) &&
           verifier.VerifyVectorOfTables(references()) &&
           VerifyOffset(verifier, VT_AUXILIARY) &&
           verifier.VerifyVector(auxiliary()) &&
           verifier.EndTable();
  }
};

struct FunctionBuilder {
  typedef Function Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_symbol(flatbuffers::Offset<flatbuffers::String> symbol) {
    fbb_.AddOffset(Function::VT_SYMBOL, symbol);
  }
  void add_address(uint64_t address) {
    fbb_.AddElement<uint64_t>(Function::VT_ADDRESS, address, 0);
  }
  void add_entry(uint64_t entry) {
    fbb_.AddElement<uint64_t>(Function::VT_ENTRY, entry, 0);
  }
  void add_blocks(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fugue::schema::BasicBlock>>> blocks) {
    fbb_.AddOffset(Function::VT_BLOCKS, blocks);
  }
  void add_references(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fugue::schema::InterRef>>> references) {
    fbb_.AddOffset(Function::VT_REFERENCES, references);
  }
  void add_auxiliary(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> auxiliary) {
    fbb_.AddOffset(Function::VT_AUXILIARY, auxiliary);
  }
  explicit FunctionBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Function> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Function>(end);
    return o;
  }
};

inline flatbuffers::Offset<Function> CreateFunction(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> symbol = 0,
    uint64_t address = 0,
    uint64_t entry = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fugue::schema::BasicBlock>>> blocks = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fugue::schema::InterRef>>> references = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> auxiliary = 0) {
  FunctionBuilder builder_(_fbb);
  builder_.add_entry(entry);
  builder_.add_address(address);
  builder_.add_auxiliary(auxiliary);
  builder_.add_references(references);
  builder_.add_blocks(blocks);
  builder_.add_symbol(symbol);
  return builder_.Finish();
}

inline flatbuffers::Offset<Function> CreateFunctionDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *symbol = nullptr,
    uint64_t address = 0,
    uint64_t entry = 0,
    const std::vector<flatbuffers::Offset<fugue::schema::BasicBlock>> *blocks = nullptr,
    const std::vector<flatbuffers::Offset<fugue::schema::InterRef>> *references = nullptr,
    const std::vector<uint8_t> *auxiliary = nullptr) {
  auto symbol__ = symbol ? _fbb.CreateString(symbol) : 0;
  auto blocks__ = blocks ? _fbb.CreateVector<flatbuffers::Offset<fugue::schema::BasicBlock>>(*blocks) : 0;
  auto references__ = references ? _fbb.CreateVector<flatbuffers::Offset<fugue::schema::InterRef>>(*references) : 0;
  auto auxiliary__ = auxiliary ? _fbb.CreateVector<uint8_t>(*auxiliary) : 0;
  return fugue::schema::CreateFunction(
      _fbb,
      symbol__,
      address,
      entry,
      blocks__,
      references__,
      auxiliary__);
}

struct Metadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MetadataBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_INPUT_FORMAT = 4,
    VT_INPUT_PATH = 6,
    VT_INPUT_MD5 = 8,
    VT_INPUT_SHA256 = 10,
    VT_INPUT_SIZE = 12,
    VT_EXPORTER = 14,
    VT_AUXILIARY = 16
  };
  const flatbuffers::String *input_format() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT_FORMAT);
  }
  const flatbuffers::String *input_path() const {
    return GetPointer<const flatbuffers::String *>(VT_INPUT_PATH);
  }
  const flatbuffers::Vector<uint8_t> *input_md5() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_INPUT_MD5);
  }
  const flatbuffers::Vector<uint8_t> *input_sha256() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_INPUT_SHA256);
  }
  uint32_t input_size() const {
    return GetField<uint32_t>(VT_INPUT_SIZE, 0);
  }
  const flatbuffers::String *exporter() const {
    return GetPointer<const flatbuffers::String *>(VT_EXPORTER);
  }
  const flatbuffers::Vector<uint8_t> *auxiliary() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_AUXILIARY);
  }
  flexbuffers::Reference auxiliary_flexbuffer_root() const {
    return flexbuffers::GetRoot(auxiliary()->Data(), auxiliary()->size());
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_INPUT_FORMAT) &&
           verifier.VerifyString(input_format()) &&
           VerifyOffset(verifier, VT_INPUT_PATH) &&
           verifier.VerifyString(input_path()) &&
           VerifyOffset(verifier, VT_INPUT_MD5) &&
           verifier.VerifyVector(input_md5()) &&
           VerifyOffset(verifier, VT_INPUT_SHA256) &&
           verifier.VerifyVector(input_sha256()) &&
           VerifyField<uint32_t>(verifier, VT_INPUT_SIZE) &&
           VerifyOffset(verifier, VT_EXPORTER) &&
           verifier.VerifyString(exporter()) &&
           VerifyOffset(verifier, VT_AUXILIARY) &&
           verifier.VerifyVector(auxiliary()) &&
           verifier.EndTable();
  }
};

struct MetadataBuilder {
  typedef Metadata Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_input_format(flatbuffers::Offset<flatbuffers::String> input_format) {
    fbb_.AddOffset(Metadata::VT_INPUT_FORMAT, input_format);
  }
  void add_input_path(flatbuffers::Offset<flatbuffers::String> input_path) {
    fbb_.AddOffset(Metadata::VT_INPUT_PATH, input_path);
  }
  void add_input_md5(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> input_md5) {
    fbb_.AddOffset(Metadata::VT_INPUT_MD5, input_md5);
  }
  void add_input_sha256(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> input_sha256) {
    fbb_.AddOffset(Metadata::VT_INPUT_SHA256, input_sha256);
  }
  void add_input_size(uint32_t input_size) {
    fbb_.AddElement<uint32_t>(Metadata::VT_INPUT_SIZE, input_size, 0);
  }
  void add_exporter(flatbuffers::Offset<flatbuffers::String> exporter) {
    fbb_.AddOffset(Metadata::VT_EXPORTER, exporter);
  }
  void add_auxiliary(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> auxiliary) {
    fbb_.AddOffset(Metadata::VT_AUXILIARY, auxiliary);
  }
  explicit MetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Metadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Metadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<Metadata> CreateMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> input_format = 0,
    flatbuffers::Offset<flatbuffers::String> input_path = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> input_md5 = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> input_sha256 = 0,
    uint32_t input_size = 0,
    flatbuffers::Offset<flatbuffers::String> exporter = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> auxiliary = 0) {
  MetadataBuilder builder_(_fbb);
  builder_.add_auxiliary(auxiliary);
  builder_.add_exporter(exporter);
  builder_.add_input_size(input_size);
  builder_.add_input_sha256(input_sha256);
  builder_.add_input_md5(input_md5);
  builder_.add_input_path(input_path);
  builder_.add_input_format(input_format);
  return builder_.Finish();
}

inline flatbuffers::Offset<Metadata> CreateMetadataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const char *input_format = nullptr,
    const char *input_path = nullptr,
    const std::vector<uint8_t> *input_md5 = nullptr,
    const std::vector<uint8_t> *input_sha256 = nullptr,
    uint32_t input_size = 0,
    const char *exporter = nullptr,
    const std::vector<uint8_t> *auxiliary = nullptr) {
  auto input_format__ = input_format ? _fbb.CreateString(input_format) : 0;
  auto input_path__ = input_path ? _fbb.CreateString(input_path) : 0;
  auto input_md5__ = input_md5 ? _fbb.CreateVector<uint8_t>(*input_md5) : 0;
  auto input_sha256__ = input_sha256 ? _fbb.CreateVector<uint8_t>(*input_sha256) : 0;
  auto exporter__ = exporter ? _fbb.CreateString(exporter) : 0;
  auto auxiliary__ = auxiliary ? _fbb.CreateVector<uint8_t>(*auxiliary) : 0;
  return fugue::schema::CreateMetadata(
      _fbb,
      input_format__,
      input_path__,
      input_md5__,
      input_sha256__,
      input_size,
      exporter__,
      auxiliary__);
}

struct Project FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ProjectBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_ARCHITECTURES = 4,
    VT_SEGMENTS = 6,
    VT_FUNCTIONS = 8,
    VT_METADATA = 10,
    VT_AUXILIARY = 12
  };
  const flatbuffers::Vector<flatbuffers::Offset<fugue::schema::Architecture>> *architectures() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fugue::schema::Architecture>> *>(VT_ARCHITECTURES);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fugue::schema::Segment>> *segments() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fugue::schema::Segment>> *>(VT_SEGMENTS);
  }
  const flatbuffers::Vector<flatbuffers::Offset<fugue::schema::Function>> *functions() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<fugue::schema::Function>> *>(VT_FUNCTIONS);
  }
  const fugue::schema::Metadata *metadata() const {
    return GetPointer<const fugue::schema::Metadata *>(VT_METADATA);
  }
  const flatbuffers::Vector<uint8_t> *auxiliary() const {
    return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_AUXILIARY);
  }
  flexbuffers::Reference auxiliary_flexbuffer_root() const {
    return flexbuffers::GetRoot(auxiliary()->Data(), auxiliary()->size());
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_ARCHITECTURES) &&
           verifier.VerifyVector(architectures()) &&
           verifier.VerifyVectorOfTables(architectures()) &&
           VerifyOffset(verifier, VT_SEGMENTS) &&
           verifier.VerifyVector(segments()) &&
           verifier.VerifyVectorOfTables(segments()) &&
           VerifyOffset(verifier, VT_FUNCTIONS) &&
           verifier.VerifyVector(functions()) &&
           verifier.VerifyVectorOfTables(functions()) &&
           VerifyOffset(verifier, VT_METADATA) &&
           verifier.VerifyTable(metadata()) &&
           VerifyOffset(verifier, VT_AUXILIARY) &&
           verifier.VerifyVector(auxiliary()) &&
           verifier.EndTable();
  }
};

struct ProjectBuilder {
  typedef Project Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_architectures(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fugue::schema::Architecture>>> architectures) {
    fbb_.AddOffset(Project::VT_ARCHITECTURES, architectures);
  }
  void add_segments(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fugue::schema::Segment>>> segments) {
    fbb_.AddOffset(Project::VT_SEGMENTS, segments);
  }
  void add_functions(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fugue::schema::Function>>> functions) {
    fbb_.AddOffset(Project::VT_FUNCTIONS, functions);
  }
  void add_metadata(flatbuffers::Offset<fugue::schema::Metadata> metadata) {
    fbb_.AddOffset(Project::VT_METADATA, metadata);
  }
  void add_auxiliary(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> auxiliary) {
    fbb_.AddOffset(Project::VT_AUXILIARY, auxiliary);
  }
  explicit ProjectBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Project> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Project>(end);
    return o;
  }
};

inline flatbuffers::Offset<Project> CreateProject(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fugue::schema::Architecture>>> architectures = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fugue::schema::Segment>>> segments = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<fugue::schema::Function>>> functions = 0,
    flatbuffers::Offset<fugue::schema::Metadata> metadata = 0,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> auxiliary = 0) {
  ProjectBuilder builder_(_fbb);
  builder_.add_auxiliary(auxiliary);
  builder_.add_metadata(metadata);
  builder_.add_functions(functions);
  builder_.add_segments(segments);
  builder_.add_architectures(architectures);
  return builder_.Finish();
}

inline flatbuffers::Offset<Project> CreateProjectDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<fugue::schema::Architecture>> *architectures = nullptr,
    const std::vector<flatbuffers::Offset<fugue::schema::Segment>> *segments = nullptr,
    const std::vector<flatbuffers::Offset<fugue::schema::Function>> *functions = nullptr,
    flatbuffers::Offset<fugue::schema::Metadata> metadata = 0,
    const std::vector<uint8_t> *auxiliary = nullptr) {
  auto architectures__ = architectures ? _fbb.CreateVector<flatbuffers::Offset<fugue::schema::Architecture>>(*architectures) : 0;
  auto segments__ = segments ? _fbb.CreateVector<flatbuffers::Offset<fugue::schema::Segment>>(*segments) : 0;
  auto functions__ = functions ? _fbb.CreateVector<flatbuffers::Offset<fugue::schema::Function>>(*functions) : 0;
  auto auxiliary__ = auxiliary ? _fbb.CreateVector<uint8_t>(*auxiliary) : 0;
  return fugue::schema::CreateProject(
      _fbb,
      architectures__,
      segments__,
      functions__,
      metadata,
      auxiliary__);
}

inline const fugue::schema::Project *GetProject(const void *buf) {
  return flatbuffers::GetRoot<fugue::schema::Project>(buf);
}

inline const fugue::schema::Project *GetSizePrefixedProject(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<fugue::schema::Project>(buf);
}

inline const char *ProjectIdentifier() {
  return "FuDb";
}

inline bool ProjectBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(
      buf, ProjectIdentifier());
}

inline bool VerifyProjectBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<fugue::schema::Project>(ProjectIdentifier());
}

inline bool VerifySizePrefixedProjectBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<fugue::schema::Project>(ProjectIdentifier());
}

inline const char *ProjectExtension() {
  return "fdb";
}

inline void FinishProjectBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<fugue::schema::Project> root) {
  fbb.Finish(root, ProjectIdentifier());
}

inline void FinishSizePrefixedProjectBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<fugue::schema::Project> root) {
  fbb.FinishSizePrefixed(root, ProjectIdentifier());
}

}  // namespace schema
}  // namespace fugue

#endif  // FLATBUFFERS_GENERATED_FUGUE_FUGUE_SCHEMA_H_
